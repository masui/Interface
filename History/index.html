<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>ユーザインタフェースの歴史と今後の展開</title>
<style type="text/css">
<!--
body {
  width:600px;
  background-color:#ffffff;
  color:#000;
}
h1 {
	color: #ffffff;
	background-color: #040904;
	margin-right: 0%;
	margin-left: 0%;
	text-align: center;
	padding: 0.5em 0.5em;
	text-indent: 0.25em;
	border-style: none;
}
h2 {
	color: #ffffff;
	background-color: #228;
	margin-right: 0%;
	margin-left: 0%;
	text-align: left;
	padding: 0.1em 0.1em;
	text-indent: 0.25em;
	border-style: none;
}
h3 {
	color: #ffffff;
	background-color: #049004;
	margin-right: 0%;
	margin-left: 0%;
	text-align: left;
	padding: 0.1em 0.1em;
	text-indent: 0.25em;
	border-style: none;
}
-->
</style>
</head>
<body>
<!--
【（広義な意味での）ユーザーインターフェースとは何か】　　4p
　　ドアノブ事例？　/　喫茶店のコースター？
【コンピュータのUI（GUI）の発展】　　　4p
　　Hypertextの話　/　昔話など
【UIに求められるもの】　　　4p～5p
　　コロンブス指数？　/　技術者はどのようにシンプルさを表現すべきか
　　NFCによる実例
　　コンピュータ（組み込み含む）のUIはどこへ行きつくか
【コラム】　　1～2p
　　書評
　　連載へつなげる内容　（アートと技術の境界が無い実例を紹介？）
-->

<h1>ユーザインタフェースの歴史と今後の展開</h1>

本誌のタイトルの「インターフェース」という言葉は
機械と機械を接続する装置や技術のことを指していますが、
人間が計算機を使うしくみのことは
「計算機インタフェース」
「コンピュータヒューマンインターフェース(CHI)」
「ヒューマンコンピュータインターフェース(HCI)」
「ヒューマンインターフェース(HI)」
「ユーザインタフェース(UI)」
などと呼ばれています。
誰もがいつでもどこでも計算機やネットワークを利用するようになってきている現在、
計算機と人間のやりとりを容易にするための
ユーザインターフェース技術は
誰にとっても非常に重要なものとなってきています。

本企画では、ここ30年ほどの計算機インタフェースの進化の歴史を振り返り、
将来のインタフェース技術の展望について考えてみたいと思います。

<p>
ユーザインタフェース技術とは
機械やシステムを人間が簡単に利用できるようにするための技術の総称です。
このような技術は非常に重要であるのに加え、
人間にとって使いにくい機械やシステムがあれば
機械やシステム側に問題があると考えるのが現在では常識になっていますが、
昔は「人間の努力や練習が足りない」と考えられることが多かったようです。

実際、楽器の演奏は難しいものですが、
楽器が下手な人が
「演奏するのが難しい楽器があるのは変だ」
などと言ったら、練習が足りない人間が何を言っているんだと思われるのが普通でしょう。

計算機や電化製品を使う場合も、
うまく使いこなせない人がそのことを恥ずかしく思ったり、
使いこなせるようになるまで頑張って練習しようと思ったりすることが
多かったようですが、
心理学者のドナルド・ノーマンが
「<a href="http://www.amazon.co.jp/dp/478850362X">誰のためのデザイン?</a>」
という本でこの考えの間違いをわかりやすく説明したおかげで、
現在はこういう考えをする開発者やユーザはほとんどいなくなったように思われます。

楽器の場合は練習すればするほど上手に演奏できるようになるものですし、
練習により愛着がわくこともありますが、
誰もが便利に使えることが望ましい機械を使うために練習や修練が必要なのであれば
困ったものだといえるでしょう。

<!--
簡単に使える
馴染みがある
複雑さとくらす
-->

<h2>ユーザインタフェースの変容</h2>

シリコンバレーの中心地で
Googleの本社があるMountain View市には
「<a href="http://www.computerhistory.org/">Computer History Museum</a>」
という博物館があり、
巨大な歴史的計算機が数多く展示されています。

初期の計算機は回路が巨大で複雑だっただけではなく、
人間が操作するための制御パネルも巨大で複雑なのが普通だったようで、
利用者は以下の写真のような制御パネルを利用して計算機を操作する必要がありました。

<p>
<img src="cd47753dddd9659436b8a27c14328fe3.png" width=600>
<p>

複雑な制御パネルといえば飛行機のコックピットを連想しますが、
昔の計算機の制御パネルは飛行機のコックピットと大きく変わるものではなかったようです。
このようなものは「操作しやすさ」とか「直感的」とかとは全く無縁のものに思われます。

このような複雑な制御パネルは専門家にしか使えないことは明らかですが、
パネルの複雑さに対応するほど複雑な用途に利用できたかどうかは疑問です。

<!-- http://blog.tabista.jp/airline/2005/12/post_25.html -->
<p>
<img src="58eadfb59b0e235916897080ff92946d.png" width=600>
<p>

一方、最近の計算機は形態も使い方もどんどんシンプルになってきています。
パソコンの入出力装置コネクタは減る一方ですし、
iPadのようなタブレット計算機には
ボタンやコネクタは数えるほどしか無いにもかかわらず、
昔に比べるとはるかに複雑な仕事ができるようになってきています。
これはすべてユーザインタフェース技術の進化のたまものだといえるでしょう。

<p>
最近はユーザのほとんどが計算機の専門家ではないのにもかかわらず、
様々なエンターテインメントに計算機を利用していますし、
記憶力が足りなかったり手足が不自由だったりといった
弱者をサポートするような用途にも
計算機が広く使われるようになってきました。

従来の計算機ユーザのほとんどは
計算機に詳しく頭脳が明晰で手先が器用な「強者」であったのに対し、
これからのユーザのほとんどはなんらかの意味での「弱者」が中心となると考えられ、
個々のユーザの弱点を補強するような用途に利用される機会がますます増えるはずです。

<p>
あらゆる人間が計算機ユーザとなることを考えると、
「いつでもどこでも」計算機が使えるだけでは不充分で、
「いつでもどこでも誰でも」使える計算機が必要になります。
様々な機器や住居などを「誰でも」苦労なく使えるようにする
「ユニバーサルデザイン」という考え方が近年注目されていますが、
現在ユニバーサルなユーザインタフェースへの大きな
パラダイムシフトが起こりつつあるといえるでしょう。

<h2>文字ベースのインタフェース</h2>

 現在使われているほとんどのパソコンでは
<b>グラフィカルユーザインタフェース</b>(GUI)が採用されており、
いわゆる「WIMP」
(ウィンドウ/アイコン/メニュー/ポインティングデバイス)
を使ってあらゆる操作を行なうようになっています。

GUIはMacintoshやWindows95の登場後に一般ユーザに浸透しましたが、
GUIが広く普及する前は、
キーボードと文字端末を利用して計算機とやりとりを行なう
<b>コマンドラインインタフェース</b>(CLI)がユーザインタフェースの主流でした。
CUIは広く普及していたことに加え、
GUIより便利に使える場面もあるため
現在のMacやWindowsのようなパソコンでも
コマンドラインインタフェースが使える環境は残っており、
CLIを好んで利用するユーザもまだまだ多いようです。
(私もそのひとりです)

<p>
初期の計算機は前の写真のような複雑な制御パネルを持っていたようですが、
計算機がより一般的に利用されるようになるにともなって、
キーボードと文字表示端末を利用するCLIが
大型計算機でも小型計算機でも広く利用されるようになりました。

大型計算機ではプログラムや計算機処理を指示するパンチカードと
呼ばれるものが利用されていたりしました。
初期のパソコンもキーボードと文字ターミナルが操作の基本になっていました。

計算機が使われるようになる以前からタイプライターが普及していたため
入力装置として自然であったことに加え、
文字列は表現力が高いために
単純な仕組みにもかかわらず複雑な入出力を利用することが可能だったからだと
思われます。

文字の入力と出力ができる文字端末さえあれば計算機を利用することができるので、
共用の大型計算機に文字端末をケーブルで接続して利用するという方法がよく使われていました。

現在のMacやiPhone, AndroidなどはUnixオペレーティングシステムが基本に
なっていますが、
UnixでももともとはCLIによるユーザインタフェースの基本になっていました。

<!-- http://catb.org/~esr/writings/taouu/html/ch02s02.html-->
<p>
<img src="ab7ab81befe7f5a4a3a9e2fef1207760.png" width=600>
文字端末VT100
<p>

<h3>CLIの基本操作</h3>

CLIの基本操作は以下のようになっています。

<ul>
<li>ユーザ入力待ち状態になっている計算機が、入力可能であることをユーザに示す記号(プロンプト)を表示する
<li>ユーザがコマンド文字を入力してから改行キーを押す
<li>コマンド文字列を計算機が解釈して実行する
</ul>

たとえばUnixでは以下のようになります。

<ul>
<li>計算機が文字端末に"<code>% </code>"のようなプロンプト文字を送り、文字端末がそれを表示する
<li>ユーザがキーボードから"<code>date</code>"のようなコマンド文字列を入力してから改行キーを押す
<li>"<code>date</code>"という文字列が計算機に送られる
<li>送られた文字列を計算機が解釈した結果、現在時刻を調べ、結果文字列を文字端末に送る
<li>計算機から送られた文字列を文字端末が表示する
<li>計算機が文字端末に"<code>% </code>"のようなプロンプト文字を送り、文字端末がそれを表示する
</ul>

このように、ユーザと計算機の間は文字列だけがやりとりされるというシンプルな構造になっているので、
計算機プログラムの作成は比較的容易です。
Unixでは "date" とユーザが入力すると "date" という名前のコマンドが実行されることになりますが、
dateコマンドは現在時刻を示す文字列を「標準出力」に出力するという処理を行なうだけで、
その結果は文字端末に送り返されて文字端末に表示されます。
つまりdateコマンドは自分の計算結果がどのようにユーザに提示されるかを気にする必要がありません。

<p>
Unixでは計算機もユーザも文字列をやりとりするだけなので、
両者を区別せずに使うことができます。
たとえばユーザが"date"と入力するかわりに
"date"という文字列を出力するプログラムを使ってdateコマンドを実行することもできますし、
"date"と書いてあるテキストファイルを使ってdateコマンドを実行することもできます。
このため、CLIで使うコマンド文字列を並べるだけでそれがプログラムになってしまいます。
このようなシンプルで汎用的な設計のおかげで
Unixはユーザから絶大な支持を得ることができました。

CLIを使ってプログラム開発をする場合、
計算機と文字列のやりとりをしながらプログラムを編集する必要があります。
たとえばUnixのedコマンドを使って文字端末でC言語のプログラムを開発するには
以下のようにプログラムを編集することになります。

<blockquote>
<pre>
% <b>ed hello.c</b>
hello.c: No such file or directory
<b>i</b>
<b>#include &lt;stdio.h&gt;</b>
<b>main(){ printf("Hello!\n"); }</b>
<b>.</b>
<b>1</b>
#include &lt;;stdio.h&gt;
<b>2</b>
main(){ printf("Hello!\n"); }
<b>d</b>
<b>i</b>
<b>main(){ printf("Hello, world!\n"); }</b>
<b>.</b>
<b>w</b>
56
<b>q</b>
% <b>cc hello.c</b>
% <b>./a.out</b>
Hello, world!
% 
</pre>
</blockquote>

printf()はC言語の関数で、
カッコの中の引数文字列を「標準出力」に出力します。
このプログラムを実行すると
計算機は"Hello, world!"とい文字列を文字端末に出力し、
文字端末はそれを画面に表示することになります。
このように、単純な入出力関数を利用するだけでインタフェースを作れてしまう点は
CLIの大きな利点といえるでしょう。

<!--標準出力 printf, scanfで作れてしまう -->

<p>
しかしこのような方法で大きなプログラムを作ることはほとんど不可能ですから、
実際には文字端末の全画面を利用してプログラムを編集する
「スクリーンエディタ」と呼ばれるプログラムが使われています。
Unixでは「vi」や「Emacs」というスクリーンエディタが古くから使われており、
今でもプログラム開発者などには人気があります。

スクリーンエディタでは全画面を利用してテキスト編集を行なうため、
画面の任意の位置に文字列を表示する必要があります。
たとえば計算機側プログラムから文字端末に対して
「画面の上から2行目/左から5桁目に"c"という文字を表示する」
といった指示をする必要があります。
一般的な文字端末というものは
計算機から送られてきた文字列がそのまま左から右に表示するようになっているので、
特別な位置に文字表示するためには
「エスケープシーケンス」という特殊な制御文字列が利用されます。
たとえば最も広く利用されていた「VT100」という文字端末では、
'ESC'(0x1b) '[' '2'(0x32) ';' '5'(0x35) 'f'
というバイト列を送ることによって
カーソルを画面の上から2行目/左から5桁目に移動することができます。
これ以外にもVT100では何十種類ものシーケンスが定義されています。

<p>
計算機にケーブルで接続されたVT100のような文字端末を利用する状況において
こういう工夫が必要になるので、
パソコン上のUnixのスクリーンエディタを利用するときは
エスケープシーケンスのようなものは必要ないはずなのですが、
これを前提としたスクリーンエディタがいまだに広く使われているため、
文字端末をエミュレートするプログラムがいまだに現役で利用されています。
たとえばMacにはTerminal.appというアプリケーションがあり、
この上でUnixのCLIを利用することができます。
Terminal.appはMacのGUI画面上のウィンドウで動作するわけですが、
その上に文字を表示するためには
viやEmacsなどからエスケープシーケンスが送られていることになります。
本物のvt100を現在利用している人は皆無と思われますが、
vt100互換の文字端末エミュレータはまだまだ現役で利用されているのが面白いところです。

<p>
人間が計算機にコマンド文字列を送ると
計算機がコマンドを実行して結果を人間に返すというCLIは
現代的なユーザインタフェースとはいえませんが、
現在でも有効な場面は少なくありません。

文字列のやりとりはハードウェア的にもソフトウェア的にも実装が簡単なので、
最低限のインタフェースだけ備えておきたい機器では
CLIだけ用意しておけば良いでしょう。
また、このような手法だと
ユーザの操作と計算機の動作が常に決まった順番で行なわれるため、
状態遷移の扱いが簡単で、
ソフトウェア作成の手間が小さくてすみます。

<p>
インターネットの基本プロトコルはCLI的なインタフェースになっています。
たとえばインターネット上のメール転送プロトコルである
SMTP(Simple Mail Transfer Protocol)
はCLIを採用しているので、
以下のようにユーザが直接SMTPサーバに接続して
メール転送を依頼することが可能になっています。

<blockquote>
<pre>
% <b>telnet smtp.example.com 25</b>
Trying 192.0.43.10...
Connected to localhost.
Escape character is '^]'.
220 smtp.example.com ESMTP Postfix
<b>mail from:masui@pitecan.com</b>
250 2.1.0 Ok
<b>rcpt to:masui@pitecan.com</b>
250 2.1.5 Ok
<b>data</b>
354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
<b>test</b>
<b>test</b>
<b>.</b>
250 2.0.0 Ok: queued as 78DD08F8535
<b>quit</b>
221 2.0.0 Bye
Connection closed by foreign host.
% 
</pre>
</blockquote>

メール転送を管理するSMTPサーバには
普通は別のメールサーバやメーラプログラムからアクセスするものですが、
CLIが採用されているおかげで、
このようにユーザが直接操作したり実験/デバッグを簡単に行なうことができます。

<!--
  文字列を入力して、リターンまたはEnterを入れると計算機に司令が飛ぶ
  それが帰ってくる
   全二重と半二重があった
   現在は半二重は想像できないかも
-->

<p>
プログラムの作成が容易であるとか、
リモートのプログラムを操作するのが簡単だとか、
他にもいろいろ利点はあるので現在でもCLIは利用されてはいるのですが、
計算機と対等のレベルでコマンドを覚えておく必要がありますし、
キーボード操作に熟練しなければ気持ちよく使うことはできないので、
一般ユーザ向けのインタフェースとしては現在ほとんど使われていません。

<h2>グラフィカルユーザインタフェース</h2>

現在の計算機はパソコンもスマートフォンも
グラフィックユーザインタフェース(GUI)で操作を行なうのが普通になっています。
前述のように、
現在主流のGUIは
WIMP
(ウィンドウ/アイコン/メニュー/ポインティングデバイス)
の操作が基本となっており、
これはパソコンでもタブレットでもスマートフォンでもほとんど同じ操作性になっています。

<h3>GUIの歴史</h3>

WIMPによるGUIはシリコンバレーのXerox PARC(Palo Alto Research Center)で開発されたもので、
1973年に開発された
<a href="http://ja.wikipedia.org/wiki/Alto">Alto</a>
という計算機がそのさきがけだと言われています。
Altoは現在のパソコンと同じように
ビットマップディスプレイを備えており、
マウスを使ってウィンドウやメニューを利用することができる先進的なものでした。

グラフィカルなインタフェースで画面上のオブジェクトを直接操作できるインタフェースとしては
1963年に開発された
<a href="http://ja.wikipedia.org/wiki/Sketchpad">SketchPad</a>
のような先駆的なシステムがありますが、
汎用のシステムとしてWIMPを採用したものはAltoが最初だと言われています。

<p>
<img src="96bf4fda6bf46b0f862f9d3c68905016.png"><br>
Alto
<p>

Altoは商用に販売されたものではありませんが、
その後Xeroxは
1981年に
<a href="http://ja.wikipedia.org/wiki/Xerox_Star">Xerox Star</a>
というワークステーションを販売し、
1982年には日本語対応した
<a href="http://sites.google.com/site/jstar8080/">JStar</a>も
販売を開始しました。
その後、Sun Microsystems社や
Silicon Graphix社などから
GUIをもつUnixワークステーションが続々と販売されるようになりました。

<!-- [[http://ja.wikipedia.org/wiki/Sun-3 Sun3]] 1985 -->
<!-- 1983 Sun2 -->

大学においても各種のGUIの研究開発が盛んに行なわれました。
1982年にはカーネギーメロン大学でAndrewシステムが開発され、
学内で広く利用されるようになりましたし、
1984年には
MITでX Window Systemが開発され、
現在でも各種のUnixマシン上で広く利用されています。

<p>
Steve JobsがPARCを見学したとき見たAltoのGUIに衝撃を受けて
これをパソコン上に実現しようと考えたことは有名です。
Appleは1983年に
<a href="http://ja.wikipedia.org/wiki/Lisa_%28%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%29">Lisa</a>
を販売しました。
また1984年には廉価版の
<a href="http://ja.wikipedia.org/wiki/Macintosh">Macintosh</a>も
販売を開始しました。

Appleを離れたSteve Jobsは1985年に
NeXT Computerを創業し、
最初の製品NeXTcubeを1988年に発売しました。

<!--
小型化したNeXTstationは1990年に発売。
-->

<!--
[[http://ja.wikipedia.org/wiki/PC-9800%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA PC9801]] 1982
[[http://ja.wikipedia.org/wiki/Lisa_%28%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%29 Lisa]] 1983
[[http://ja.wikipedia.org/wiki/Macintosh Macintosh]] 1984

X 以前にも、ビットマップディスプレイを使ったシステムは存在していた。ゼ
ロックスは、Alto（1973年）とStar（1981年）を開発している。アップルは、
Lisa（1983年）と Macintosh（1984年）を開発した。UNIX関連では、Andrew
Project（1982年）とロブ・パイクのBlit端末（1984年）がある。
-->

<h3>GUIの衝撃</h3>

GUIは多くの計算機資源を具体的に目に見えるものにしたことが重要です。

CLIではあらゆる計算機資源に名前をつける必要があり、
どんな操作を行なうときもその名前を利用する必要がありましたが、
GUIでは必ずしもファイルに名前をつけなくくても操作を行なうことができます。

<p>
GUIは「<b>直接操作</b>」を可能にします。
直接操作とは、実世界で書類を扱うのと同じような方法で計算機データを扱う方法で、
書類をつまんだ手を動かすと書類が動くのと同じような感覚で、
ファイル上でマウスボタンをクリックして動かすとファイルが動きます。
このような動きは<b>連続的</b>かつ<b>可逆的</b>であり、
逆の操作を行なうともとの状態に戻すことができます。

コマンドラインインタフェースではこのようなことができません。
データを移動するためには移動パラメタが必要ですし、
もとに戻すためには逆のパラメタをを指定する必要があります。

また、GUIでは具体的な対象に対して具体的な操作を行なうことができます。
操作対象も操作の量も目で見えます。
CLIでは、操作対象は名前で指定しなければなりませんし、
操作の量は数字やシンボルで指定しなければなりません。

GUIの操作はハンドルを回して車を運転するようなものですが、
CLIでは % wheel right 30 のようなコマンドを打つのと同じようなもので、
操作性が圧倒的に違うことは明らかです。

大抵の人にとって、シンボルや数値を利用して何かを操作するより、
具体的な直接操作の方がわかりやすいものです。

文字の読み書きができない子供でもGUIならば使うことができる場合があります。

<p>
GUIでは各種の「GUI部品」が発明され利用されてきました。
メニューやスライダーがその代表的なものです。

アイコンや
メニューは複数の選択枝の中から必要なものを選択するための部品です。
メニューとGUIは直接関係があるわけではなく、
GUIが登場するより前からメニューは利用されていましたが、
テキストの列の中から必要なものを番号などで選ぶよりも、
項目の列の中から自分に必要なものをクリックする操作の方が簡単ですし、
階層的なメニューを構成することによって大量の項目から選択を行なうこともできるため、
現在のGUIでは非常に広く利用されています。
またスライダーは、小さな画面でも大きな情報を見られるようにするための工夫で、
長いテキストやWebページなどを閲覧するのに無くてはならない存在になっています。

メニューやスクロールバーのおかげで、多くの情報を画面から隠すことができるようになりました。
メニューを使うと選択項目を隠してしまうことができるので
インタフェースがすっきりします。
家電製品のリモコンにボタンが多いのはメニューが使えないからです。

<h3>GUIとオブジェクト指向</h3>

現在は様々な言語によるオブジェクト指向プログラミングが広く利用されていますが、
オブジェクト指向プログラミングは20年前はまだまだ常識的な技術にはなっていませんでした。
しかしGUIのプログラム開発はオブジェクト指向プログラミングと相性が良いため、
GUIの流行とオブジェクト指向プログラミングによる開発の流行は
相乗効果があったように思われます。

オブジェクト指向プログラミングでは、
ソフトウェアで扱う対象をひとまとめにして扱うことができるようにします。
GUIで扱うウィンドウやメニューなどをオブジェクトとして定義し、
これらに対して...
オブジェクト指向プログラミング言語を利用して
ウィンドウやメニューなどをオブジェクトとして定義すると、
ウィンドウを生成したりメニューを操作したりといった操作を行なう
GUIプログラミングを比較的簡単に行なうことができるようになります。*****

オブジェクト指向プログラミング上のGUIツールキット

198x年にはNeXT社によりInterface Builderが開発され、
オブジェクト指向プログラミングとグラフィカル設計を組み合わせた開発手法が
(Cocoa, VisualC++など)
一般的になり現在まで続いています。

<h3>GUI部品とその進化</h3>

GUIで広く利用されている
メニューやスクロールバーのような部品は
MacでもWindowsでも使い方が似ています。

メニューやスライダのようなGUI部品に似たものが現実世界に存在するわけではなく、
これらは純粋に計算機操作のために発明された工夫です。
ゼロからの発明ですから、最初から良いものが存在したわけではありません。
現在のメニューやスクロールバーの形態は時間をかけてGUIが進化した結果であり、
生物が時間をかけて進化してきたのと同じように、
時間をかけて現在のような形に収束していることになります。

<h4>メニュー</h4>

  最もよく使われるし研究されてる
    メニューはSmalltalkから
      http://d.hatena.ne.jp/sumim/20060510/p1
    階層メニューはUCSD Pascalから持ってきた
     キーボードベースかもしれない 1978
  パイメニューとかもある

<p>
<img src="b8fda3611776f5377eb47d707af57a6d.png"><br>
Altoのウィンドウのメニュー
<p>

<h4>スクロールバー</h4>

  スライダは進化している
  [[http://d.hatena.ne.jp/sumim/20060823/p1 Macのスクロールバーはいかにしてできあがったか]]
   [[http://www.computerhistory.org/events/lectures/appleint_10281997/appleint_xscript.shtml Origins of Apple Human Interface]]

<p>
<img src="98ad768b8492d0af7799086c78b22923.png"><br>
Smalltalkのスクロールバー
<p>

<!--
 Interface Builder
 [[http://squab.no-ip.com/collab/uploads/61/altoscroll01.png]]
[[http://ja.wikipedia.org/wiki/Xerox_Star Xerox Star]] 1981
[[http://sites.google.com/site/jstar8080/ JStar]] 1982
[[http://ja.wikipedia.org/wiki/PC-9800%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA PC9801]] 1982
[[http://ja.wikipedia.org/wiki/Lisa_%28%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%29 Lisa]] 1983
[[http://ja.wikipedia.org/wiki/Macintosh Macintosh]] 1984
[[http://ja.wikipedia.org/wiki/Sun-3 Sun3]] 1985
Windows2.0 1987
Windows3.1 1993
[[http://geekyschmidt.com/wp-content/uploads/2008/03/nextstep-screenshot.png NeXTStepの左スクロールバー]]
-->

<h3>GUIの欠点</h3>

GUIは便利なものですが、
CLIのプログラミングに比べると
快適なGUIを提供するためのプログラミングは桁違いに複雑になってしまいます。
見栄えの良いグラフィクスを表示するだけでも大変なうえに、
ユーザの気ままな操作やエラーに対して適切に反応させるには
あらゆる条件を想定したプログラミングが必要になります。
ポインティングデバイスとキーボードは同時に使われる可能性がありますし、
システムの状況を常にユーザにフィードバックする必要がありますし、
システムに対してリアルタイムに要求を伝える必要もあるので、
注意深い並列的プログラミングも必要になります。

<p>
GUIでは直接操作によって様々な作業を楽に行なうことができますが、
CLIの方が便利な場合も少なくありません。

例えば、名前や数字を明示的に指定する場合


  文字列関係の処理はやりにくくなった
   *ab*.txt みたいな指定ができない
  数字的処理も簡単ではない
   3行消す、などと言えない
   正確な操作ができない場合もある

 (慣れと直感)
  メニューみたいなもの、スライダみたいなものは存在しないのに直感になってる
  マウスはつかいにくいのに直感的になってる

<p>
現在のパソコンGUIはマウスのようなポインティングデバイスうまく操作しなければならないため、
これが苦手な人にとってはCLIの方が都合が良いということもあります。
このような問題に関しては「ユニバーサルデザイン」のところで説明したいと思います。

<h2>GUIの拡張</h2>

WIMPベースのGUIの基本的な要素は
初代Macintoshから大きく変わっていないといえるでしょう。
アイコン、プルダウンメニュー、フォルダ表示、スクロールバー、
各種ボタンなどのGUI要素は驚いたことに20年以上変わっていません。

人間があるインタフェースに一旦慣れてしまうと、
それより多少良いインタフェースが登場したとしても
「現状でいいや」という慣性が働いてしまうため、
新しいものに移ることが難しくなります。

現在の乗用車では誰もが丸いハンドルを使っていますが、
もしハンドルよりも使いやすいものが発明されたとしても
誰もそちらに移ることはないでしょう。

最適化問題を解くとき、
ローカルミニマムに落ち込んでいるのに似ているかもしれません。

GUIを改良しようという様々な試みが行なわれてきました。

<h3>3次元インタフェース</h3>

現在のGUIでは、
沢山のウィンドウを開くと収拾がつかなくなるという問題があります。
この問題を解決するため、MacではSpacesなどといった工夫がされています。

小さな2次元平面上にウィンドウを並べるかわりに、
広大な3次元空間上にウィンドウを並べることにすれば
多くの画面を配置することができるだろうという考えにもとづき、
3次元表示を行なうデスクトップが何度も提案されてきました。
しかし3次元デスクトップは結局全く流行することがありませんでした。
そもそも人間は3次元空間を把握することがそれほど得意ではありませんし、
マウスやキーボードを使って3次元空間を操作したり移動したりするのは
簡単ではないことが問題だったと考えられます。

また、3次元のものを動かす場合、
3次元の物体を動かしているのか、
自分が3次元空間の中にいるのかわからなくなることが多いという問題も指摘されています。[Norman]

いずれにせよ、計算機を操作するために3次元空間を導入することは
難しすぎることは確かだったようです。

<h3>ズーミングインタフェース</h3>

3次元空間を扱うことは人間にとって難しいかもしれませんが、
2次元画面を任意のサイズに拡大/縮小できるようにして
ウィンドウを配置することにすれば、いくらでも画面を扱うことが
できるようになるかもしれません。

こういう考えにもとづき、画面を無限に拡大したり縮小したり
できるようにした「ズーミングインタフェース」(ZUI)が15年ぐらい前に
提案され、いっとき様々な研究が行なわれました。

最初に開発されたズーミングインタフェースは
New York UniversityのKen Perlinによる「Pad」システムですが、
この後継としてBen Bedersonにより開発された「Pad++」や、
「Jazz」
「<a href="http://www.cs.umd.edu/hcil/jazz/">Piccolo</a>」
などのズーミングインタフェースツールキットが
開発され、非常に期待されたことがあります。

<p>
<img src="http://www.windsorinterfaces.com/images/photomesa4.jpg" width=400><br>
「PhotoMesa」
<p>

% ズーミングとフィルタリングで何でもできる

ズーミングインタフェースを用いると大量のデータを扱うことができることに加え、
可逆的な操作が可能だという利点があります。
なんらかの操作によって画面の一部にズームインした場合、
逆の操作でズームアウトさせることは自然ですから、
ズームインして一部を拡大表示した後で
ズームアウトして全体を表示するといった操作を
なめらかに直感的に行なうことができます。

ズーミングインタフェースはこのような利点があるため、
新しいインタフェースとしてかなり期待されましたし、
テレビのようなコンスーマ機器に搭載しようという製品企画もあったようですが、
結局最終的に製品に採用されたものはほとんどありませんし、
パソコンのデスクトップとしても流行することはありませんでした。

あまり流行しなかったのは、
直観的なズーミング操作インタフェースが存在しなかった
ことと、
迷子になって途方にくれてしまうことがある
ことが最大の理由と思われます。

うっかり何も無い場所でズームインすると画面が
真っ白になってしまい、自分の居場所が全くわからなくなってしまうからです。
もちろんズームアウトするともとの画面に戻るのですが、
一瞬でも途方に暮れる状況になるのは好ましいことではありません。


また、
複数の場所を同時に閲覧することが難しい
ことも問題だったかもしれません。

情報が散在している場合、
必要な情報をうまく閲覧するためには
空間把握能力と操作の熟練が必要であることが問題だったのでしょう。

<h2>GUI以降のインタフェース</h2>

将来の計算機がどのように利用されるかについては様々な夢が考えられています。

あらゆる操作を音声で実行できるようにするのが理想だと考える人達が
音声認識/音声理解システムの研究開発を行なってきた結果、
ユーザの発話をかなりの精度で理解することができるようになってきました。

直観的なジェスチャでやりたいことを指示するのが理想だと考える人達は、
画像認識などによるジェスチャ認識システムの開発を行ない、
Kinectのような装置が実用になってきました。

音声やジェスチャを使わなくても、思ったことがすぐに実行できるような環境が
必要だと考える人達は、
脳や神経の信号を計算機に直結して操作を行なう
Brain-Machine Interfaceの夢について考え、
実際ある程度神経と計算機を接続できるようになってきたりしています。

このようなシステムが本当に実用になることはかなり先の話だと思われますが、
これらに共通しているのは「計算機の筐体は必要ない」ということです。
やりたいことが簡単にできるようであれば、計算機の実体などは不要であり、
頭を使わない直観的な行動によってやりたいことが実行されるということが重要になるのは
確かなことでしょう。

見えないところで動く計算機は「Invisible Computer」と呼ばれます。
Donald Normanは、
Information Applianceが重要になると言っています。

Norman: The Invisible Computer

また、Mark Weiserは
Calm Computingを提唱していました。

いずれの場合も、計算機がどんどん控え目になり、
計算機を使うという感覚が消えていくことが将来目標になっているといえるでしょう。


計算機的なものを今すぐ完全に消してしまうことは難しいでしょう。
現在重要なデータはすべてパソコン画面やブラウザ上に表示されるようになっているので、
これらをいきなりInvisibleにするといっても賛同は得られないでしょう。

しかしキーボードやマウスがなくても簡単に同じ結果が得られるのであれば
キーボードにこだわる人はいないでしょうから、
こういった入力デバイスからインビジブルにしていくことを考える必要があるでしょう。

「実世界インタフェース」という研究が行なわれており、
これにより様々な装置がインビジブルになっていっています。

<hr>

 音声とかジェスチャーとか
 どこにでもあるユビキタス/モバイル時代になる
 インビジブル / Calmになるのは間違いなし
 誰でも直感的に使えるようにする

<h3>実世界インタフェース</h3>

xxxで紹介したように、
GUIの画面操作は「直接操作」と呼ばれてはいますが、
本当に画面上にファイルが存在したりするわけではありません。
あたかもファイルが画面の上に有るように、
またそれを指でさわっているように
自ら「騙される」ことによって直接操作感覚を得ていることになります。

<!--
% 本当に存在するプリンタは代理物で扱わなければならない
-->

ファイルをプリンタに出力したい場合、
画面上のプリンタのリストの中から自分が使いたいプリンタを選択することになりますが、
似たような外見をしているプリンタも多いので、
リスト中のプリンタ表示が実際にはどのプリンタのことを示しているのか
わかりにくいこともよくあります。
目の前にある文書を目の前にあるプリンタで印刷したい場合でも、
画面上のGUIを使ってデータの流れを指示する必要があり、
これではとても「直接操作」ということはできません。
プリンタに直接データを流し込むような身体的操作を利用することができれば
このような問題は少なくなくなるでしょう。

<p>
キーボードやディスプレイのような計算機専用のインタフェース装置を使うのではなく、
実世界に存在する慣れ親しんだものを活用して
本当の直接操作を実現するインタフェース手法が
<b>実世界インタフェース</b>と呼ばれており、
これからの計算機利用の方法を示すということで注目されています。
<!--
今後「実世界」で計算機を使うことがあたりまえであることが認識されるにつれ、
このような言葉が使われる機会は減ってくるであろう。
-->

自働ドアや照明スイッチのように、
すでに実世界で広く利用されている装置は沢山ありますが、
これらも実世界インタフェースの一種と考えられます。

<h3>ユビキタスコンピューティング</h3>

19xx年、Xerox PARCのMarc Weiserは
「ユビキタスコンピューティング」という概念を提唱しました[]。
この言葉は
「いつでもどこでも計算機を使える環境」という意味で使われることが多いようですが、
MITの石井裕氏が指摘しているように[]、
その本当の主旨は計算機が環境にすっかり溶け込んでインビジブルになることを目指したものでした。

使い方がよくわからない装置やセンサに埋もれて暮らすのがユビキタスコンピューティングではなく、
センサや計算機の存在を意識しなくても自然に計算機を利用できる環境こそが
ユビキタスコンピューティング環境だということになります。

<p>
Weiserはその後
このような技術を「Calm Technology」という名前で呼ぶようになりました。
また、こういった環境は
「アンビエント」
「Disappearing Computing」などと呼ばれることもあります。

計算機を持ち歩いて使う「モバイルコンピューティング」や、
計算機を服のように身につけて使う「ウェアラブルコンピューティング」は、
真のユビキタスコンピューティングに到るまでの途中段階の一形態といえるでしょう。

<p>
あらゆる人間が計算機ユーザとなることを考えると、
「いつでもどこでも」計算機が使えるだけでは不充分で、
「いつでもどこでも誰でも」使える計算機が必要になります。
装置や住居を「誰でも」苦労なく使えるようにする
「<b>ユニバーサルデザイン</b>」という考え方が近年注目されていますが、
これはユビキタスコンピューティングの考え方と高い親和性があります。

現状の「ウェアラブルコンピューティング」は
特殊な人が特殊な用途に使うような匂いがありますが、
ユビキタスコンピューティングの究極の姿は
ユニバーサルデザインと同じ方向を向いており、
「いつでもどこでも誰でも」使える機器を目指しているといえるでしょう。

<h3>ユビキタスとユニバーサル</h3>

<h4>情報機器のバリア</h4>

ユニバーサルデザインと似たような意味で
「<b>バリアフリー</b>」という言葉が使われることがありますが、
こちらは
現在使われている機器に「バリア」が有るのが前提となっているように感じられるのに対し、
ユニバーサルデザインという言葉は、
最初からバリアの存在しない公平な機器を設計するべきであるという、
より新しい考え方を表現しています。

<b>
現在の計算機には沢山のバリアがあります。

CLIを採用した計算機は
指一本でもなんとか使うことができましたが、
GUIを採用した計算機では
マウスのようなポインティングデバイスを動かしたり
クリックしたりする操作ができないと
まともに使えないようになってしまいました。

このため、年配の方などの場合、
ダブルクリックができなかったり
細かい画面を制御するための微妙なマウス操作が難しかったりするために
GUIを使いこなせないといった問題が発生しています。

また、数字や文字のみを出力する計算機は、
画面表示のかわりに音声で出力を読み上げることによって、
目の見えない人でも比較的簡単に使うことができましたが、
GUIベースのシステムは音声読み上げが難しいため
目の見えない人には非常に使いにくいものとなってしまいました。

このように、
インタフェースを進化させたために
かえってバリアが増えてしまうという傾向が多く見られていました。

<p>
現在、ほとんどの計算機は
若者やビジネスマンを対象に作られており、
キーボードやマウスを上手に操作できない人のことは
あまり重視されていませんし、
目が見えない人や手足が不自由な人のことはさらに
考慮されていないことが多いようです。

一般的な入出力装置を使用できない場合は
特殊な「障害者用機器」を使用する必要がありますが、
このような機器は値段が高かったり入手が難しかったりするため
広く使われているとはいえません。

情報機器が最初から
ユニバーサルデザインにもとづいて設計されていれば
このような問題は発生しなかったはずです。

<h4>ユニバーサルデザインを促進するインタフェース手法</h4>

ところが、
近年はこのような状況が大きく改善されつつあるように思われます。

最近の計算機インタフェースの研究では
「モバイルコンピューティング」と
「実世界指向インタフェース」が
大きな流れとなっていますが、
これらの研究分野では
ユニバーサルデザインに貢献する技術が数多く提案されているからです。

<h4>モバイルコンピューティングとユニバーサルデザイン</h4>

モバイルコンピューティングとは何であるかについては
いろいろ議論があります\bib{塚本昌彦. モバイルコンピューティング. December 2000, 岩波書店}。
ノートPCを持ち歩いて使うことを
モバイルコンピューティングと呼んでいた時代もありましたが、
現在は、
PDAや携帯電話を持ち歩いていろいろな場所や状況で使うことを
モバイルコンピューティングと呼ぶことが多いようです。
モバイルコンピューティングの究極的な形態として、
衣服のように身につけて使う
「ウェアラブルコンピュータ」や
人間の体と計算機を一体化してしまう
「インプランタブルコンピュータ」
なども近年よく話題になっています。

<p>
固定された机の上の大きな計算機画面を、
両手で使うキーボードで操作する場合と異なり、
モバイルコンピューティングで使われる機器には
制限がつきものです。

持ち歩いて使うPDAや携帯電話などは
どうしても画面が小さくなりますし、
制限のある入力装置しか使うことができません。

歩きながら使ったり満員電車の中で使ったりする場合は、
画面を見ることができないかもしれませんし、
片手しか使うことができないかもしれません。

このように各種の制限のあるモバイルコンピューティング環境は、
目や手足が不自由な人の状況と変わりませんから、
モバイルコンピューティングのために工夫された入出力装置や手法には
そのまま
ユニバーサルデザインとして通用するものが沢山あります。

小さな画面に効果的に情報を表示するための技術は、
目の悪い人のための表示手法として使うことができますし、
計算機を片手で操作するための技術は
手足の不自由な人が計算機を使うための技術として使うことが
できます。

同じ携帯計算機でも、
歩きながら使いたいこともあれば
机の上で使いたいこともあるでしょう。

モバイル環境など
いろいろな状況で使えるようにするためには
必然的にユニバーサルデザインが普及すると考えられます。

<h3>実世界指向インタフェースとユニバーサルデザイン</h3>

計算機内部のデータと計算機の外の世界のデータや事物は
感覚的にかなり異なっており、
変換のためには各種の入出力装置が要るのが普通ですが、
これらの間のギャップは工夫次第でかなり小さくすることができます。
例えば、
紙の上に式を書けば自動的にその右に答が印刷されるような計算機や、
英単語を見ただけでその意味を教えてくれるような眼鏡があれば便利でしょう。

このように、計算機内部のデータと現実の事物の間のギャップを最小にして、
計算機を意識することなく透明な存在として活用するための研究が
近年盛んになってきており、このような手法を総称して
「実世界指向インタフェース」と呼んでいます。

<p>
このように、
実世界指向インタフェースの研究は、もともとは
計算機画面上での計算環境を普通の紙や机の上でも実現したいといった
要求から始まったという面がありますが、

特殊な装置を使うことなく、
機械や計算機の存在を意識せずに
直感的にこれらを操作するという考え方は多くの場面で有効です。

例えば、
ドアの前に立つという単純な行動により開く自動ドアは大変便利なのと同じように、
名刺を見ると名簿データが開く計算機は大変便利でしょう。

<p>
このような、
直感的な操作にもとづく実世界指向インタフェースは
計算機操作の様々なバリアを取り除くのに大変効果的です。

たとえば、
よくできた実世界指向インタフェースにもとづく
プレゼンテーションシステムでは、
表示したいスライドを投影面に向けるだけで
プロジェクタ画面が投影されるかもしれませんが、
普通のPCとプロジェクタを使う場合は、
PCを立ち上げて/
プレゼンテーションプログラムを立ち上げて/
表示したいスライドの入っているファイルを開き/
スライドを探して/
PCをプロジェクタに接続して/...
のように沢山の操作と労力が必要になってしまいます。

前者の場合は誰でも簡単に使えると思われるのに対し、
現在のPCはバリアに満ちているといえるでしょう。

<p>
実世界指向インタフェースが普及すれば
様々なバリアは自然に消滅すると思われます。

たとえば電車に乗るとき、
現在は
自動改札機(=計算機)を納得させるために
券売機で切符を購入するというバリアを越える必要がありますが、
誰がどれだけ電車に乗ったかを自動的に検出する
実世界指向システムを使えば、
このようなバリアは消滅するため自然とユニバーサルデザインが
実現されることになります。


<h3>ユニバーサルデザインのガイドライン</h3>

***この部分はもっと前に?***

障害のために発生する不幸の大部分は
人為的な要因によるものであると思われます。

例えば私は
抵抗のカラーコードが読めなかったり
発光ダイオードの赤と緑が区別できなかったりするので、
人為的な要因によって不幸な状況になることはありますが、
山の紅葉に気付かずに不幸な状況になることはありません。
人為的に引き起こされる不幸は
注意することにより解決可能です。


ユニバーサルデザインという考え方を提唱した
ノースカロライナ州立大学の\person{Ron Mace}らは
以下のように
ユニバーサルデザインの7つの原則を示しています。

\begin{itemize}
\item どのような能力を持つ人に対しても有用であること
\item 人によって様々な使い方ができること
\item 経験/知識/言語/集中度によらず簡単に理解できること
\item 周囲の環境やユーザの感覚能力によらず必要な情報をユーザに伝えられること
\item 誤った操作をしても安全であること
\item 余分な力を必要としないこと
\item ユーザの様々な姿勢や動作に対応できる大きさや場所があること
\end{itemize}

これらはあらゆる機器に関する原則ですが、
情報機器のインタフェースに対してもそのままあてはまります。
これらを常に頭に置いて、
ユニバーサルなインタフェースのデザインを行なうことが重要でしょう。

<p>

インターネット時代の現在、
Webのインタフェースが非常に重要になってきているので、
誰もがWebページの内容を理解することができるようにするための
注意が必要です。
例えば、\verb+<img>+タグなどで画像が表示されている場合は、
その内容を\verb+<alt>+タグで表現しておけば、
目の見えない人でも読み上げシステムを使って内容を知ることが
できます。

たとえばW3CのWeb Accessibility Initiative (WAI)では
Webページを誰もが読めるようにするための
ガイドラインが提案されていますし、
Center for Applied Special Technology (Cast)の配布している
Bobbyというツールを使えば
Webページのアクセシビリティを検証することができます。


障害をもつ人のために
特別な機器やインタフェースを設計製造するのは
面倒ですし儲からないと考えられがちですが、
ユニバーサルデザインにもとづいた設計により
儲かる製品を作れる場合があります。

例えば、
電動アシスト自転車は
長崎や長野のような坂の多い町では沢山売れているそうです。

そもそも計算機は人間の能力を拡大するために使われるべきものです。

高齢者でも/子供でも/機械操作が苦手な人でも/障害があっても、
誰もが自分の能力を計算機によって拡大できるように
なっていって欲しいものだと思います。

<h2>インタフェース雑感</h2>

<h3>慣れと直感</h3>

あらゆるインタフェースは直感的であるべきだと言われています。

iPadの操作は直感的だから子供でも老人でも使えるのだ言う人もいます。

しかし直感とは何でしょうか?

iPhoneやiPadのホーム画面には
様々なアイコンが並んでおり、これにタッチすることにより
アプリケーションが動くようになっています。
このような機能は本当に「直感的」といえるのでしょうか?

実際のところ、アイコンにタッチするとアプリケーションが動くという動作は
本当に直感的なものではなく、
多くのユーザがパソコンのGUIに慣れているからだと思われます。
パソコンGUIではアイコンをクリックすると
そのアイコンで表現されるアプリケーションが動いたり
データを操作したりすることができるため、
アイコンをクリックするという操作はおなじみのものですが、
パソコン以外でそのような機能を持つものはほとんどありませんし、
GUIがポピュラーになる以前にそのような行動を直観的と感じていた人は
いないと思われます。
つまり、GUIがポピュラーになり、多くの人々がそれに慣れたことによって、
アイコンによりアプリケーションが起動することが直感的だと思われるように
なったということになります。
アイコンは本当に直感的なのではなく、アイコンの操作に慣れた人が
多いということを示しています。


ペンを使って絵を書いたり操作を指示したりする方法は直感的だと
思われていますが、人間がペンで上手く字や絵を描くことができるのは
長い学校生活で練習を重ねた結果であり、
練習による慣れが無ければペン操作を直観的と感じることはなかったでしょう。

アイコンやペンは、慣れや練習の結果直感的と感じられるようになったものです。
アイコンを直観的に使うために練習は必要ありませんが、
ペンを直感的に使えるようになるには膨大な練習が必要です。
しかし学校で練習することにより直観的にペンを使うことができるようになる
ことのメリットは非常に大きいため、どこの世界でも
ペンを使う練習には長い時間をかけています。

インタフェースは直感的であるというのはそのとおりですが、
最初から直感的に使えるものは存在しません。
練習や慣れによって直感的と感じられるのです。
自動ドアは原理が単純で覚えやすく、非常に直感的なインタフェースです。
自動ドアをはじめて見た人は使い方がわからないかもしれませんが、
一度でも見れば使い方がわかり、直感的だと感じるようになるはずです。

新しいインタフェースを作る場合、
最初は直感的と感じられなかったとしても、
ユーザがすぐに慣れることができるようならば
それは直感的なものとして受け入れられるでしょう。
こういったインタフェースを「イディオム」と呼ばれます。

「のどから手が出る」のような慣用句を自分で思いつく人は少ないでしょうが、
一度聞いたらその印象を忘れることはできないでしょうし、
自分でその言葉を活用することもできるでしょう。
アイコンやメニューのような直感的なGUI部品を
インタフェースのイディオムと呼びます。

GUIでは沢山の有用なイディオムが発明されてきましたが、
新しい実世界インタフェースのイディオムが必要とされています。

<h3>複雑さとの闘い</h3>

前に書いたようにGUIの作成は大変

複雑なインタフェースを単純な方法で置き換えることができる場合があります。

複雑な装置を使わなくても
卵を立てるには


ユーザにとって直観的で使いやすいGUIを実現するためには
沢山のプログラミングが必要なことが多いため、
トータルとしての複雑さの量は変わらないという説もありますが[]、
単純な方法がまだ発見されていないという場合もよくあります。

パソコン画面の一部をWebにアップロードしたいとき、

(1) 画面のスクリーンダンプをとってファイルにセーブする
(2) 画像編集ソフトウェアを起動する
(3) スクリーンダンプされたファイルを開いて一部を選択し、選択部分をファイルにセーブする
(4) セーブされたファイルをWebにアップロードする

という手順をとるのが普通でした。
画像編集ソフトウェアを起動したり、ファイルに名前をつけたり、
画像をアップロードできるWebサイトを利用したり、
やりたいことは単純なのにもかかわらずかなりの手間がかかります。

私が開発したGyazoというシステムを使うと、

(1) Gyazoアプリを起動する
(2) アップロードしたい領域をマウスカーソルで指定する

という手順だけで自動的に領域の画像がWebサイトにアップロードされて
URLが返されるようになっています。

Gyazoを利用するようになってから、

--------
テキストエディタは同じような操作を何度も繰り返さなければならないことがよくあります。
すべての文字列Aを文字列Bに置き換えたいようなことはよくありますが、
Aを検索してからBに置き換えるという操作を何度も実行するのは面倒ですから、
ある文字列を別の文字列に置き換えるという機能が大抵のエディタには用意されています。

では、すべての数字を括弧  したい場合はどうすればよいでしょうか。

そのようなコマンドはエディタに用意されていませんから、
特別な機能が用意されていない限り、
ひとつずつ自力で処理していかなければならないでしょう。

私が作成したDynamic Macroというシステムを使うと、
このような編集処理の繰り返しを簡単に実行することができます。
Dynamic Macroの原理は単純で、
「同じ操作を2度以上繰り返した後で繰り返しキーを押すと
繰り返された操作をもう一度実行する」というものです。
文字列Aを文字列Bに置き換えたい場合は、
Aを検索してからBに置き換える操作を二度繰り返しした後で繰り返し実行キーを何度か押せばいいですし、
.....場合は
.....すると同じ操作が繰り返されます。

この方法を使うと、どのような繰り返し操作でも簡単に再実行させることができるので、
search&replaceのような特殊な機能をエディタに用意する必要がなくなってしまいます。

---------
システムのインパクトをシステムの複雑さで割った値を私は「コロンブス指数」と呼んでいます。
単純なのに役にたつシステムはコロンブス指数が高いことになります。

GyazoやDynamic Macroのようなシステムは
非常に便利ですが、システムの構造は単純なので
コロンブス指数が大きくなっています。

複雑な処理を行なうのに複雑な操作が必要なのは仕方がないかもしれませんが、
簡単なことを行なうためにも複雑な処理が必要な場所が沢山残っているのは問題です。
コロンブス指数が高いシステムをまだまだ発明していく必要があるでしょう。

<h2>全世界プログラミング</h2>

情報を自由に発信したり、
情報流れを自由に制御したりするためには
情報流の接続を定義するだけではなく、
情報流を自由にプログラミングができる必要がある。

APIを提供しているWebサービスが増えているのは良い傾向で、
誰もが簡単に世界中の情報を入手したり
世界中の装置を制御したりする
<b>マッシュアップ</b>が簡単にできるようになってきた。
このような状況では、
世界中の誰もが世界中の装置を自由に操作することができる
<b><a href="http://pitecan.com/blog/2006/06/blog-post.html">全世界プログラミング</a></b>が
可能になりつつある。

<p>
全世界プログラミング環境では全世界の人間が全世界の装置を制御することができる。

センサを多用したソフトウェアを作るという点では、
マイコンボードを利用したセンサプログラミングに似ているが、
センサの知識/ハードウェア工作技術/プログラミングテクニックなどが乏しい人間でも
簡単に全世界のセンサのプログラミングを行なえようになる点が重要である。

全世界プログラミングが一般化すれば、
趣味のプログラミングが再び流行するだけでなく、
生活環境も大きく変わる可能性がある。
例えば、
電灯や家電製品を操作したいときはスイッチやリモコンではなく適切なセンサを利用するのが普通になれば、
家の設計方法も変わってくるだろう。
状況に応じて留守宅の画像を中継したり録画したりするプログラムが簡単に利用できるようになれば、
防犯の方法は大きく変わるだろう。
全世界プログラミングの普及により、
時代遅れのビジネスが消滅したり、新しいビジネスのジャンルが出現する可能性もあるだろう。

<p>
全世界プログラミングの普及には時間がかかると考えられるが、
現在でもセンサを利用したプログラミングはある程度実用化されているので、
段階的にレベルを上げていくことが可能だと思われる。

<p>
<b>既に実用になっているもの</b><br>
ある条件が成立した場合に特定の処理を実行させるというような
簡単なプログラムは広く利用されている。
目覚まし時計の時刻設定は、ある時刻になったときにベルを鳴らすというプログラミングだと
考えることができるし、
ある水量になると水道を停止する風呂の自動給水システムも一種のプログラミングだといえるだろう。
ある日付のある時刻になると特定のチャンネルの番組を録画するという
ビデオ予約システムもこのようなプログラミングの一種である。

<p>
<b>各種のセンサの利用</b><br>
時刻以外の様々な条件を利用すると、
目覚まし時計をセットするのと同じぐらい簡単に、
以下のような処理をプログラムすることができるようになるだろう。
センサを単純に利用した実世界プログラミングの例として
以下のような応用が考えられる。

<ul>
<li> 人がいない部屋のテレビを消す
<li> 人がいない部屋では目覚ましを鳴らさない
<li> ビールがなくなると注文フォームを表示する
<li> キーボードに力が入ると、現在見ているページがブックマークされる
<li> 寝ると照明が消える
<li> 夜になると空気清浄機が静かになる
<li> 汚れるとトイレが自動的に洗浄される
</ul>

<p>
<b>遠隔地のセンサの利用</b><br>
前の例ではセンサの位置とアクションが発生する位置は同じであったが、
インターネットを介して遠隔地のセンサにアクセスすることによって
以下のようなプログラミングが可能になる。

<ul>
<li> 遠方の家族の様子を知る
<li> 水道が使われていないと通報する
<li> 泥棒を検出
<li> 波や風の様子を調べる
</ul>

<p>
<b>新しい応用</b><br>
センサに何の関係もないアクションを関連づけることも可能である。
現在はこのような応用はほとんど存在しないが、
新しいエンターテインメントやアプリケーションが生まれる可能性がある。

<ul>
<li> ブログが炎上すると警報が鳴る
<li> ニューヨークの天気でBGMを変化させる
<li> 全世界「ピタゴラマシン」
</ul>

このようなプログラムを作成する場合、
ディスプレイ上でのエディタでテキストを編集するよりも、
具体的な操作で条件とアクションを指定する方がわかりやすい。
たとえばアナログ型の目覚まし時計では
針の位置を動かしてアラーム時刻をセットするようになっているが、
針の位置で時刻を表現するという情報提示手法や、
針の位置が一致するという条件指定は人間にとってわかりやすいため、
アラーム時刻をセットするという実世界プログラミングを
誰でも行なうことができるのだといえるだろう。

一方、一昔前のビデオデッキでは数字で時刻やチャンネルを指定するのが普通であったが、
時刻やチャンネルを数字で指定することは抽象的でわかりにくいため、
一般にビデオ録画予約は難しいと思われがちであった。

普通のプログラミングにおいても、
変数に名前をつけたり
条件や繰り返し操作を指定するような抽象的処理は難しいが、
ユーザから見えるものを実際に操作してプログラムを作成する方が
わかりやすいことが多い。
従来型の計算機においては、
変数などを利用した抽象的思考を行なうことなく
具体的な操作をもとにしてプログラミングを行なうことができるようにする方法として
<b>例示プログラミング</b>が提唱されており、
また
扱う対象をすべて視覚化することによりイメージをつかみやすくする
<b>ビジュアルプログラミング</b>のようなシステムも研究されているが、
全世界プログラミングにおいても同様の手法の適用が有効と思われる。
特にユビキタス環境では
プログラムが扱う対象が実世界に存在する具体的なものであることが多いので、
これらの手法を自然に利用することができるという利点がある。

<p>
テキストを利用する従来型のプログラミングでは、
あらゆる対象をテキストで扱わなければならないため、
「居間のテレビで映画を見る」ことを表現するには、

<blockquote>
<pre>
watch_movie('West Side Story','livingroom','TV1')
</pre>
</blockquote>

という具合に
「居間」「テレビ」「映画」などに名前をつけて扱う必要があるが、
自分の目の前にあるテレビにわざわざ名前をつけて表現するのは面倒かつ間違いを誘発しやすい。
「TV1」のような名前のかわりに、
テレビそのものもしくは
その写真のような代理物を使うことができれば、
はるかに直観的にプログラミングを行なうことができるはずである。

抽象的理解が必要なテキストをなるべく使わず、
なるべく実物を利用してプログラミングを行なう
<b>実世界指向プログラミング</b>
の手法を開発するべきであろう。

<p>
インターネットの普及、センサの一般化、計算機のユビキタス化により、
世界中の情報を誰もが好きなように加工して利用できるようになった。
人間の歴史において、このようなことが可能になったのは初めてのことであり、
将来の展開が期待される。

<h2>ユビキタスインタフェースの展望</h2>

ユビキタス環境におけるインタフェースが
これからの計算機利用の主流になることは間違いない。
自動車の運転に丸いハンドルが使われているように/
QWERTY配列のキーボードが文字入力の標準として利用されているように/
マウスがグラフィカルユーザインタフェースの標準として利用されているように/
なんらかの装置や操作手法が
ユビキタス環境におけるデファクトスタンダードとなるはずである。

それがどのようなものであれ、
一度世の中に浸透してしまったものは簡単に変えることはできない。
車のハンドルの形を変えることもキーボードの配列を変えることも難しい。
ユビキタス環境のインタフェースとして適切ではないものが
デファクトスタンダードとなって浸透してしまう可能性も大きいだろう。

ユビキタス環境のインタフェース手法は、
電気のスイッチやキーボードのように、今後何十年も使い続けられる可能性があり、
そのようなインタフェースを考えるということは大変刺激的なことであり、
その責任は重大だといえるだろう。
叡智を結集して準備しておく必要がありそうである。

<hr>
[[予測インタフェース]]
文字入力のいろいろ
 キーボードの入力
 ポインティングデバイスによる入力
インタフェースは誰が改革しているか
 学会なのか
関連話題
 表計算
  鈴木則久の選ぶ発明
   GUIも?
 十大発明
 ユビキタスとユニバーサル
 慣れと直感

貧乏な話
  Macのメニューバー
    場所を節約するために考え出されたものらしい

</body>
</html>




3 [[[実世界インタフェース]]]

 具体的に見えるが本当に具体的なわけではない
 ファイルとか本当に存在すると信じているだけ
 本当に存在するプリンタは代理者で扱わなければならない
全世界プログラミング


[[予測インタフェース]]
文字入力のいろいろ
 キーボードの入力
 ポインティングデバイスによる入力
インタフェースは誰が改革しているか
 学会なのか
関連話題
 表計算
  鈴木則久の選ぶ発明
   GUIも?
 十大発明
 慣れと直感


